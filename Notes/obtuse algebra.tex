\documentclass[12pt]{article}

% Packages
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{tikz, tikz-cd}
\usepackage[shortlabels]{enumitem}

\usepackage{mathrsfs}

% Problem Box
\setlength{\fboxsep}{4pt}
\newlength{\myparskip}
\setlength{\myparskip}{\parskip}
\newsavebox{\savefullbox}
\newenvironment{fullbox}{\begin{lrbox}{\savefullbox}\begin{minipage}{\dimexpr\textwidth-2\fboxsep\relax}\setlength{\parskip}{\myparskip}}{\end{minipage}\end{lrbox}\framebox[\textwidth]{\usebox{\savefullbox}}}

% Environments
\setlist[enumerate]{nosep}
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\sepline}{\rule{\textwidth}{0.4pt}}

% Tikz Environments
\newenvironment{drawing}{\begin{center}\begin{tikzpicture}}{\end{tikzpicture}\end{center}}
% \tikzcdset{row sep/normal=0pt}
\newenvironment{cd}{\begin{center}\begin{tikzcd}}{\end{tikzcd}\end{center}}


% Document Formatting
\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}

% Math Formatting
\newcommand{\ds}{\displaystyle}
\newcommand{\isp}[1]{\quad\text{#1}\quad}
\newcommand{\tc}[1]{, \qquad \text{#1}}
\newcommand{\mc}[1]{, \qquad #1}
\newcommand{\cfa}[1]{, \qquad \text{for all $#1$}}

% mathbb
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}

% mathcal
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\RR}{\mathcal{R}}
\newcommand{\ZZ}{\mathcal{Z}}

% symbols
\newcommand{\eps}{\varepsilon}
\renewcommand{\phi}{\varphi}
\renewcommand{\emptyset}{\varnothing}

% Delimiters
\newcommand{\<}{\left\langle}
\renewcommand{\>}{\right\rangle}

% Relations
\newcommand{\isom}{\cong}
\newcommand{\seq}{\subseteq}
\newcommand{\teq}{\trianglelefteq}
\newcommand{\tensor}{\otimes}

\newcommand{\inc}{\hookrightarrow}
\newcommand{\To}{\longrightarrow}
\newcommand{\Mapsto}{\longmapsto}

\newcommand{\eqby}[1]{\overset{\mathrm{(#1)}}{=}}

% Math Roman
\newcommand{\op}{\mathrm{op}}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\codom}{codom}

\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Tor}{Tor}
\DeclareMathOperator{\Ann}{Ann}

% Other
\newcommand{\eqc}{\overline}
\newcommand{\udl}{\underline}


\title{Algebra \\
    \large 
}
\author{}
\date{}


\begin{document}

We assume some amount of set theory.

ordered tuples and finite cartesian product

\sepline

The definitions given here are not good for intuition.
The main purpose is to provide (robust?) set-theoretic \emph{implementations} of familiar algebraic constructions.
This is a key distinction to be made---I am essentially assuming the reader is familiar with most if not all of the concepts and is able to recognize that the definitions (stroke implementations) adequately capture the necessary functionality.

A mathematical concept in the mind is characterized by some \emph{information}---that being the information necessary to understand the concept.
In my usage ``information'' does not exist in the mathematical world, but rather it exists in each individual mathematicians mind.
We hope that this information generally agrees across minds, and in such cases we consider the information characterizing a mathematical object to be the information which is common in the minds of the mathematical community at large.
It is this standard of information to which we will hold definitions.

In order to capture the information of a mathematical concept, we will use \emph{data}---something which does exist in the mathematical world.
Again, I have my own usage of the word ``data,'' which is luckily more concrete than that of ``information.''
My usage will hopefully become more clear as you read on, but suffice it to say that data is a specific mathematical construction intended to represent the information of some mathematical concept.

To be a bit more opaque, I will employ an analogy and some precise yet non-mathematical terminology.
We can consider mathematical concepts like fictional characters.
When we gives names to these concepts, there is no actual referent (though Salmon and I would prefer designatum, here) to which the name applies (refers/designates you get the idea).
(Unfortunately, my choice of the word ``concept'' for a mathematical audience now conflicts with the point I am making because we can of course refer to concepts, as I have been doing.)
If you're willing to take my word for it---which you absolutely should not---the sort thing I have been calling a ``concept'' is better described in other terms, namely ``sense.''
For normal sorts of things, you can think of the sense of a name as the tether between the name itself and the referent.
The name (word) ``goose'' has some sense attached to it which allows us to pick out the actual animal, i.e., the goose.
One can think of the sense of the word ``goose'' as that thing which allows you to read and understand that it refers to the goose.

Anyway, definitions are gonna look like this:

\begin{fullbox}
    A \keyword{whimple} $W$ is given by the following data:
    \begin{enumerate}[(1)]
        \item an aggle-poogle $A$,
        \item a buzzo $B$ with impermeable flingos,
        \item a crundo $C$ (called the \emph{crun} inside $W$),
    \end{enumerate}
    such that
    \begin{enumerate}[(i)]
        \item $A$ and $B$ are equivalent as aggle-poogles,
        \item each dellon of $C$ is also a dellon of $A$.
    \end{enumerate}
    Say $W$ is a whimple or $W = (A, B, C)$ is a whimple.
\end{fullbox}

In other words, definitions of mathematical objects will be given as set-theoretic implementations in terms of collections of data satisfying certain axioms.
Then to name such an object, we write it as the ordered tuple of data.

\sepline

If $A$ and $B$ are sets, a subset $F \seq A \times B$ is called \keyword{functional} if for each $a \in A$ there is exactly one $b \in B$ such that $(a, b) \in F$.

A \keyword{function} $f$ is given by the following data:
\begin{enumerate}[(1)]
    \item a set $A$ called the \emph{domain} of $f$ (denoted ``$\dom f$''),
    \item a set $B$ called the \emph{codomain} of $f$ (denoted ``$\codom f$''),
    \item a functional subset $F \seq A \times B$ called the \emph{graph} of $f$.
\end{enumerate}
We say that $f$ is a function \emph{from $A$ to $B$}, denoted $f : A \to B$ or $A \xrightarrow{f} B$.

Given $a \in A$, the unique element $b \in B$ such that $(a, b) \in F$ is called the \keyword{value} of $f$ at $a$, often denoted by $f(a)$, though sometimes denoted by $fa$ or $f_a$.
This is can also be called the evaluation of $f$ at $a$ or the image of $a$ under $f$.

This definition adapted from [Ronald Brown, TOPOLOGY AND
GROUPOIDS: A Geometric Account of General Topology,
Homotopy Types and the Fundamental Groupoid]

\sepline

We make a brief distinction here between our specific \emph{definition} of the word ``function'' and the (more general) conceptual \emph{notion} of a function.
It is impossible to say in words precisely what the latter is, but we can make reference to it by the role it serves in the mathematical world.
At one point or another---hopefully rather early in their career---a mathematician will acquire the correct notion of a function.
The sense in which the notion is \emph{correct} is that it is consistent with the notions of the vast majority of mathematicians.


We might ask the mathematician, ``What is a function?''
To which they might respond, ``A function from $A$ to $B$ is a rule which assigns, to each element of $A$, an element of $B$.''
You---the reader---can now act as an impartial third party to me---the author---and this other mathematician I have manufactured.
With any luck, you are able to read and understand both this definition and my own definition of the word ``function.''
Moreover, I hope you agree that they both refer to the same \emph{thing}---that being the notion of a function.


The goal of the above definition is that any sufficiently experienced mathematician will agree that I am using the word ``function'' consistently with broader mathematics, even if some of the specifics are different.
In other words, my definition is attempting to capture the notion of a function by the set-theoretic data which characterizes it.


To be explicit, we are not defining functions per se, rather we are setting up a correspondence between functions $f : A \to B$ and triples of data $(A, B, F)$ satisfying our definition of function.

In a completely set theoretic construction, we would identify every function $f$ with its corresponding triple of data, i.e., $f = (A, B, F)$.
In which case, we are essentially claiming that there is a bijection between functions in the usual sense and their corresponding triples.

$g = (C, D, G)$ is a 


The justification for this sort of definition is that it ensures two functions $f : A \to B$ and $f' : A' \to B'$ are equal

\sepline

The domain of $f$ can be recovered from its graph $F$ as follows:
\[
    \dom f = \{a \mid (a, b) \in F \text{ for some } b\} = A.
\]
On the other hand, the codomain of $f$ cannot be recovered in this way.
Instead, we find the following subset of the codomain called the \keyword{image} of $f$:
\[
    \im f := \{b \mid (a, b) \in F \text{ for some } a\} \seq B.
\]
The domain of $f$ and the evaluation can also be used to find the image as follows:
\[
    \im f = \{f(a) \mid a \in A\} \seq B.
\]
Lastly, the graph of $f$ can be recovered from the domain and the evaluations as follows:
\[
    \Gamma_f := \{(a, f(a)) \mid a \in A\} = F.
\]



If desired, $B^A$ is used to denoted the set of all functions from $A$ to $B$.


\sepline

Let $S$ be a set.
We define the following functions:

the \keyword{identity} function $\id_S : S \to S$ where $a \mapsto a$,

the \keyword{diagonal} function $\Delta_S : S \to S \times S$ where $a \mapsto (a, a)$,

the unnamed (component interchange) function $\lambda_S : S \times S \to S \times S$ where $(a, b) \mapsto (b, a)$.




\newpage

Let $S$ be a (nonempty?) set and $n$ be a nonnegative integer.

The \keyword{$n$th cartesian power} of $S$ is the set of all $n$-tuples of elements of $S$, denoted
\[
    S^n
        = \underbrace{S \times S \times \cdots \times S}_{n \text{ times}}
        = \{(a_1, \dots, a_n) \mid a_i \in S\}.
\]
By convention, we take $S^0 = \{()\} = \{\emptyset\}$ (the set containing only the empty tuple/set).

An \keyword{$n$-ary operation} on $S$ is a function $S^{n} \to S$.

Notably, a $0$-ary (nullary) operation is a function $f : \{\emptyset\} \to S$.
In other words, $f$ picks out a single element of $S$, namely $f(\emptyset) \in S$.
In fact, there is a bijective correspondence between the elements of $S$ and the nullary operations on $S$, given by
\begin{align*}
    S &\longleftrightarrow \{\text{nullary operations on } S\}, \\
    a &\longleftrightarrow (\emptyset \mapsto a).
\end{align*}
Under this correspondence, we can consider distinguished elements of a set to be nullary operations, and vice versa.
This is not a super important point, but simply makes the following definitions more concise, maybe.
Is it worth it? Who is to say?

\sepline

We want more than static sets---we want to be able to do stuff with the sets.
Similar to our definition of ``function,'' we want to define the term ``algebraic structure.''
Put in an unhelpfully circular way, an algebraic structure is the sort of mathematical construction inside of which we can perform algebraic activities.
In the fundamental cases, it consists of a set and some rules for how we can manipulate the elements of the set, e.g., operations.
This paragraph is devoid of meaning.
I am going to provide a set-theoretic implementation now.


An \keyword{algebraic structure} $A$ (simple/on a set?) is given by the following data:
\begin{enumerate}
    \item a set $S$, called the \emph{underlying set} of $A$ (denoted ``$|A|$''),
    \item some operations $\alpha, \beta, \dots$ of any arity on $S$.
\end{enumerate}
We say $A = (S, \alpha, \beta, \dots)$ is an algebraic structure.

There will usually only be finitely many operations on $S$ and in any case there isn't, we will use more compact notation.

\sepline



A \keyword{magma} $M$ is given by the following data:
\begin{enumerate}[$\bullet$]
    \item a set $S$,
    \item a binary operation $f : S \times S \to S$.
\end{enumerate}
We say $M = (S, f)$ is a magma.

A magma $M$ is (naturally) an algebraic structure $(S, f)$.

It is common convention to notate the binary operation with a symbol called a (binary) \emph{operator}---common examples include the following:
\[
    + \quad \times \quad \cdot \quad * \quad \star \quad \circ
\]
This is of course not a comprehensive catalog, though it covers most of the basic cases.
If we choose the star `$\star$' to represent our binary operation, we write `$a \star b$' to mean the image in $S$ under $f$ of the pair $(a, b) \in S \times S$.
In other words, $f$ describes a rule which takes two elements $a, b \in A$ and produces a third element of $S$, denoted 
\[
    a \star b = f(a, b).
\]
This new element $a \star b \in S$ might be called many different things depending on the actual context.

We will say things like ``$S$ is a set with a binary operation $\star$'' or ``$\star$ is a binary operation on the set $S$.''
For brevity, we will also write ``$(S, \star)$ is a magma'' or possibly ``$(S, f)$ is a magma'' if we want to emphasize the fact that the binary operation is a function $S \times S \to S$.

In the broader mathematical world, it is common to consider only a single binary operation on a set at one time---there are many sets with `canonical' operations---which can lead to the set alone being taken as proxy for the magma.
For example, to refer to what we call ``the magma $(S, \star)$,'' one might instead say ``the set $S$ \textit{equipped with} a binary operation $\star$.''
The difference here is subtle and a passing glance is not likely to reveal a discrepancy beyond the obvious linguistic one.
And indeed there is no difference to one interfacing with mathematics in its most pure conceptual form.
But you and I---dear reader---are confined to the relentlessly imperfect and finite bounds of language.
When we do mathematics, we must undertake the impossible challenge of justifying that the sense connecting our mathematical referents to our mathematical language is justified, but can only do so either in the very same mathematical language or in some natural language.
(The latter is what a mathematician might call `intuition' (for the more cultured `being loosey goosey' or `feeding the geese')).

I trailed off, but the minor point is that it is unreasonable to be fully explicit all of the time.
And while there are sometimes good reasons to `compress' mathematical data into containers not designed for it, there should be a way to unpack that data when necessary (in my opinion of course).
I would also say that neither formality nor explication exist solely on single axis of `less' or `more,' where one must simply pick a single point along that axis.
A thinner dictionary can be seen as either `clean and elegant' or `intuitive and superficial,' while a thicker one as either `rigorous and complete' or `cluttered and illegible' (find more creative or meaningful adjectives).
A proof on either end of this can also be more or less transparent/opaque/illuminating/aesthetic/motivating.
(Hot take things have many aspects and rarely does a single aspect determine its quality.)

We are rarely interested in a general binary operation and will most often require it to have some additional structure.
In such cases, however, we will need to define a particular binary operation and prove that it has the desired structure.
For this reason---I would argue---it is worth having the language to talk about general binary operations.

(There is a diversion here where I lament about having to prove certain elementary properties of objects without having the proper language to even talk about the way in which those objects possess those properties.
To make matters worse, it is often the case that the desired result is essentially some form of ``niceness'' in the sense that we are showing that some hypothetical bad situation never occurs. In which case, when we are using the object for its intended purpose, we can sweep certain technical nuances under the rug.
So because the goal is to be able to ignore the nuance, one has to synthesize a complete model of this nuance only to discard it the moment it reveals its own unimportance.)

\sepline

An \keyword{algebraic structure} $A$ is given by (some or all of) the following data:
\begin{enumerate}[(1)]
    \item an \emph{underlying} algebraic structure, denoted explicitly by $\udl{A}$ unless otherwise specified,
    \item some \emph{auxiliary} algebraic structures/objects,
    \item some homomorphisms between these algebraic structures.
\end{enumerate}

An algebraic structure \keyword{class/type} is a \emph{signature} of data for constructing an algebraic structure.
The signature prescribes the following: whether or not and from which category an underlying object is required, whether or not and from which category any auxiliary objects are required, whether or not and from which category any morphisms are required.
Additionally, the signature prescribes some \emph{coherence conditions} which must be satisfied by the supplied data.

In other words, an algebraic structure class/type describes a format/template for constructing a more narrow sort of object.
Any algebraic object which conforms to the template, is said to be of the class/type in question.

Whenever an algebraic object $A$ of type $\mathcal{A}$ has an underlying structure $\udl{A}$, then we very closely identify 

hey bud these are just categories. just use categories

\sepline

A \keyword{magma} $M$ is a type of algebraic structure given by the following data:
\begin{enumerate}[(1)]
    \item an underlying set $\udl{M}$,
    \item a binary operation on $\udl{M}$ (a function $\udl{M} \times \udl{M} \to \udl{M}$).
\end{enumerate}

\sepline

Let $M = (\udl{M}, \odot)$ and $N = (\udl{N}, \otimes)$ be magmas.

\sepline

In order to notate an expression containing multiple applications of the operation, we use parenthesis, e.g.,
\[
    a \star (b \star c) = f(a, f(b, c)) \isp{and} (a \star b) \star c = f(f(a, b), c).
\]
In general, it is not well-defined to write an expression like `$a \star b \star c$,' as it is possible that the result is dependent on the order in which we apply the operation.
In cases where the this order does not matter, we can make sense of such notation.

A binary operation $\star$ on a set $S$ is called \keyword{associative} if
for all $a, b, c \in S$ we have
\[
    (a \star b) \star c = a \star (b \star c)
\]

A magma $(S, \star)$
\begin{itemize}
    \item (ass) is \keyword{associative} if $(a \star b) \star c = a \star (b \star c)$ for all $a, b, c \in S$,
    \item (id) has \keyword{identity} if there exists $e \in S$ such that $e \star a = a \star e = a$ for all $a \in S$,
    \item (inv) has \keyword{inverses} if for every $a \in S$ there exists $b \in S$ such that $ab = ba = e$,
    \item (comm) is \keyword{commutative} if $a \star b = b \star a$ for all $a, b \in S$.
\end{itemize}

A magma $(S, \star)$ satisfying certain properties typically has a more specific name.
We say $(S, \star)$ is a
\begin{itemize}
    \item \keyword{semigroup} if (ass) it is associative,
    \item \keyword{monoid} if (ass, id) it is associative and has an identity,
    \item \keyword{group} if (ass, id, inv) it is associative, has an identity, and has inverses,
\end{itemize}
Most of these will simply take ``commutative'' as an adjective, though we usually say \keyword{abelian group} to mean a commutative group, i.e.,
\begin{itemize}
    \item \keyword{abelian group} if (ass, id, inv, comm) it is associative, has an identity, has inverses, and is commutative.
\end{itemize}

Chart:
\begin{center}
    \begin{tabular}{r|cccc}
         & ass & id & inv & comm \\
            \hline
        magma & - & - & - & - \\
        semigroup & x & - & - & - \\
        monoid & x & x & - & - \\
        comm.\ monoid & x & x & - & x \\
        group & x & x & x & - \\
        abelian group & x & x & x & x \\
    \end{tabular}
\end{center}

semigroup bad, just add identity to get monoid.

``you can define lots of things, but that doesn't mean you should study them.'' - Dave Morrison

\sepline

A \keyword{monoid} is given by the following data:
\begin{enumerate}[(1)]
    \item s set $S$,
    \item a distinguished element $e \in S$,
    \item a binary operation $\star$ on $S$,
\end{enumerate}
such that
\begin{enumerate}[(i)]
    \item (ass) $(a \star b) \star c = a \star (b \star c)$ for all $a, b, c \in S$,
    \item (id) $e \star a = a \star e = a$ for all $a \in S$.
\end{enumerate}
In which case, we say $(S, e, \star)$ is a \keyword{monoid}.

\sepline

Let $(S, e, \cdot)$ be a monoid.
(For simplicity, write $ab = a \cdot b$ for all $a, b \in S$.)

Given $a, b \in S$ such that $ab = e$, we say that $a$ is a \keyword{left inverse} of $b$ and $b$ is a \keyword{right inverse} of $a$.
If in addition $ba = e$, then we say that $a$ is an \keyword{inverse} of $b$, and vice versa.
Equivalently, we might say
\begin{itemize}[nosep]
    \item $a$ and $b$ are inverses (of each other),
    \item $a$ is inverse to $b$,
    \item $a$ and $b$ are inverse (to one another).
\end{itemize}
Additionally, we say that $a$ and $b$ are \keyword{invertible} in the monoid.

(One must be careful when using the word ``invertible,'' as it is relative to both the underlying set and the operation---e.g., every element of $\Z$ is invertible with respect to addition, though only $1$ and $-1$ are invertible with respect to multiplication.)

Note $a$ and $b$ are inverses if and only if one is both a left and right inverse of the other.

In general mathematics, it is more common to hear the phrase ``$a$ is \textit{the} inverse of $b$'' rather than ``$a$ is \textit{an} inverse of $b$.''
Indeed, in most nice cases, there is only one inverse.
In turns out that this uniqueness holds in any monoid, as we will now demonstrate.

\begin{proposition}
    If $a, b, c \in S$ are such that $ab = ca = e$, then $b = c$.
\end{proposition}

\begin{proof}
    $b \eqby{id} eb = (ca)b \eqby{ass} c(ab) = ce \eqby{id} c$.
\end{proof}

In particular, the common value of $b$ and $c$ is an inverse of $a$.
It follows that an element of a monoid is invertible whenever it has both a left and a right inverse---the proposition implies that the two are equal.

\begin{corollary}
    Inverses are unique.
\end{corollary}

\begin{proof}
    If $b$ and $c$ are both inverses of $a$, the proposition implies $b = c$.
\end{proof}

Hence, every invertible element of the monoid in fact has a unique inverse.
If $a \in S$ is invertible, then we denote \keyword{the inverse} of $a$ might be denoted by one of the following
\[
    -a \qquad a^{-1} \qquad \frac{1}{a} \qquad \overline{a} \qquad a'
\]

\sepline

Let $(G, e, \cdot)$ be a group, i.e., a monoid with all elements invertible.
Since the inverses in a monoid are unique, so too are the inverses in a group.
And since every element has an inverse, there is a well-defined function 
\begin{align*}
    \iota : G &\To G, \\
        g &\Mapsto g^{-1},
\end{align*}
where $g^{-1}$ is \textit{the} inverse of $g$ in the group.
This function has the following properties:
\begin{enumerate}[(i)]
    \item $\iota \circ \iota = \id_G$
    \item $\iota(g \cdot h) = \iota(h) \cdot \iota(g)$, i.e., $(gh)^{-1} = h^{-1}g^{-1}$
\end{enumerate}

\sepline

Let $G = (S, e, \cdot)$ be a group.
We can define a new binary operation $\odot$ on $S$ as follows:
\[
    g \odot h := h \cdot g \isp{or} \mu_\odot = \mu_\cdot \circ \lambda_G.
\]
Denote the algebraic structure $G^\op = (S, e, \odot)$.
We claim $G^\op$ is a group.
Indeed $(S, \odot)$ is a magma and $e \in S$ is a distinguished element, so we have the required data. (unless i later require the inversion map for groups)
We check the axioms now:
\begin{itemize}[nosep]
    \item (ass) $(g \odot h) \odot k = k \cdot (h \cdot g) = (k \cdot h) \cdot g = g \odot (h \odot k)$,
    \item (id) $g \odot e = e \cdot g = g = g \cdot e = e \odot g$,
    \item (inv) $g \odot g^{-1} = g^{-1} \cdot g = e = g \cdot g^{-1} = g^{-1} \odot g = e$, where $g^{-1}$ is the inverse of $g$ in $G$. 
\end{itemize}
Hence, $G^\op$ is a group, called the \emph{opposite group} of $G$.

If $\iota : S \to S$ is the inversion function of $G$, then we have
\[
    \iota(g \cdot h) = \iota(h) \cdot \iota(g) = \iota(g) \odot \iota(h).
\]
That is, $\iota$ specifies a group homomorphism (what's that bud?) $G \to G^\op$.
In fact, this is an isomorphism and $(G^\op)^\op = G$.


\sepline

To be extremely pedantic, let
\[
    \ZZ = \{\dots, -3, -2, -1, 0, 1, 2, 3, \dots\}
\]
denote the set of integers.
I emphasize that this is a set with no additional structure.
It doesn't matter which specific set-theoretic structure it has---choose your favorite.

We define a binary operation $+$ on $\ZZ$ such that $a + b$ is `the sum of $a$ and $b$,' for all $a, b \in \ZZ$.
This seems a little circular, and could definitely be formalized better.
We define the abelian group $\Z = (\ZZ, 0, +)$, called the additive group of integers.

Typically, the term ``addition'' is reserved for any operation on a set that is sufficiently similar to the usual addition of integers.
In particular, $\Z$ addition is an abelian group.
In fact, there is a sense in which addition over the integers is the most fundamental nontrivial abelian group.



\sepline

Let $X$ be a set.

A \keyword{formal sum} in $X$ is given by the data of a function $c : X \to \Z$, written as
\[
    c = \sum_{x \in X} c_x \cdot x.
\]
The value $c_x = c(x) \in \Z$ is called the \keyword{coefficient} of $x$.
When we interpret $c$ as a function $X \to \Z$, it is called the \emph{coefficient function}.
The notation is meant to suggest multiplying the coefficient $c(x) \in \Z$ with the element $x \in X$, and taking the sum over all such products.

Since $\Z$ is an abelian group under addition, the set of functions $\Z^X$ is also an abelian group under componentwise addition:
\[
    (a + b)(x) = a(x) + b(x).
\]
Equivalently, this gives us an addition on the set of formal sums, with
\[
    a + b
        = \sum_{x \in X} a_x \cdot x + \sum_{x \in X} b_x \cdot x
        = \sum_{x \in X} (a + b)_x \cdot x
        = \sum_{x \in X} (a_x + b_x) \cdot x.
\]
For each $a \in X$, there is a characteristic function $\chi_a : X \to \Z$ defined by
\[
    \chi_a(x) = \begin{cases}
        1 & x = a, \\
        0 & x \ne a.
    \end{cases}
\]

A \keyword{finite formal sum} in $X$ is a formal sum $\sum_{x \in X} c_x x$ with only finitely many nonzero coefficients, i.e., $c_x \ne 0$ for finitely many $x \in X$.

The set of finite formal sums in $X$ may be denoted as any of the following:
\[\arraycolsep=1em
    \begin{array}{cccc}
        \Z \cdot X & \Z X & \Z[X] & \Z^{(X)}
    \end{array}
\]


\sepline

A \keyword{formal sum} in $S$ is a symbolic object which suggests some form of addition over the elements of $S$, but no specific operation is present.
Intuitively, we want to build notation for `the most general sort of addition' over the elements of $S$.



The formal sum of two elements $a, b \in S$ is written as ``$a + b$'' or ``$b + a$''.
Ideally, we would want to interpret these expressions as the same thing.
In other words, we are imagining the operation to be commutative.

The formal sum of three elements $a, b, c \in S$ is written as ``$a + b + c$'' (or any permutation of the order).
With this notation---in particular, not putting parentheses---we are imagining the operation to be associative.


\sepline

Let $A = (\AA, 0, +)$ be an abelian group.




\newpage
\sepline

A \keyword{ring} $R$ is an algebraic structure with the following data:
\begin{enumerate}[(1)]
    \item distinguished elements $0, 1 \in |R|$,
    \item a binary operation $+$ called \emph{addition} such that $(|R|, 0, +)$ is an abelian group,
    \item a binary operation $\cdot$ called \emph{multiplication} such that $(|R|, 1, \cdot)$ is a monoid,
\end{enumerate}
such that the two operations satisfy the following distributivity properties:
\begin{enumerate}[(i)]
    \item (dist) $a \cdot (b + c) = (a \cdot b) + (a \cdot c)$,
    \item (dist) $(a + b) \cdot c = (a \cdot c) + (b \cdot c)$.
\end{enumerate}

By convention, the \emph{order of operations} in a ring puts multiplication before addition.
Because of this, we can omit parentheses the order of operations can be deduced.
Moreover, we typically write the multiplication without the operator, though sometimes use it for clarity.
On the other hand, we always write the operator for addition.
For example, we can write the following
\[
    (a \cdot b) + (c \cdot d) = ab + cd.
\]
The additive inverse of $a \in R$ is denoted by $-a$, and we replace the plus sign with a minus sign when adding an inverse, e.g.,
\[
    a + (-b) = a - b.
\]
The multiplicative inverse of $a \in R$, when it exists, is denoted by $a^{-1}$.



\begin{enumerate}[(i)]
    \item $\mu(a, \alpha(b, c)) = \alpha(\mu(a, b), \mu(a, c))$, i.e., 
    \begin{cd}[column sep=large]
        R \times R \times R \ar[rr, "\Delta_R \times \id_R \times \id_R"] \dar["\id_R \times \alpha"]
            && R \times R \times R \times R \ar[rr, "\id_R \times \lambda_R \times \id_R"]
            && R \times R \times R \times R \dar["\mu \times \mu"]\\
        R \times R \ar[rr, "\mu"]
            && R
            && R \times R \ar[ll, "\alpha"']
    \end{cd}
    \begin{cd}
        R^3 \ar[rr, "\Delta \times \id \times \id"] \dar["\id \times \alpha"']
            && R^4 \ar[rr, "\id \times \lambda \times \id"]
            && R^4 \dar["\mu \times \mu"]\\
        R^2 \ar[rr, "\mu"']
            && R
            && R^2 \ar[ll, "\alpha"]
    \end{cd}
    \item $\mu(\alpha(a, b), c) = \alpha(\mu(a, c), \mu(b, c))$, i.e.,
    \begin{cd}
        R^3 \ar[rr, "\id \times \id \times \Delta"] \dar["\alpha \times \id"']
            && R^4 \ar[rr, "\id \times \lambda \times \id"]
            && R^4 \dar["\mu \times \mu"]\\
        R^2 \ar[rr, "\mu"']
            && R
            && R^2 \ar[ll, "\alpha"]
    \end{cd}
\end{enumerate}

\newpage
\sepline

A \keyword{ring} is given by the following data:
\begin{enumerate}[(1)]
    \item a set $R$;
    \item a binary operation $+$ on $R$ called \emph{addition};
    \item a binary operation $\cdot$ on $R$ called \emph{multiplication};
\end{enumerate}
such that
\begin{enumerate}[(i)]
    \item $R$ is an abelian group under addition:
    \begin{enumerate}
        \item (associativity) $(a + b) + c = a + (b + c)$,
        \item (identity) $0 \in R$ called \emph{zero} such that $0 + a = a + 0 = a$,
        \item (invertibility) for all $a \in R$ there exists an $-a \in R$ such that $a + (-a) = 0$,
        \item (commutativity) $a + b = b + a$;
    \end{enumerate}
    \item $R$ is a monoid under multiplication:
    \begin{enumerate}
        \item (associativity) $(a \cdot b) \cdot c = a \cdot (b \cdot c)$,
        \item (identity) $1 \in R$ called \emph{one} such that $a \cdot 1 = 1 \cdot a = a$;
    \end{enumerate}
    \item multiplication is distributive over addition:
    \begin{enumerate}
        \item (left distributivity) $a \cdot (b + c) = (a \cdot b) + (a \cdot c)$,
        \item (right distributivity) $(a + b) \cdot c = (a \cdot c) + (b \cdot c)$.
    \end{enumerate}
\end{enumerate}

\sepline


\begin{proposition}
    In a ring $R$ we have the following properties:
    \begin{enumerate}[(a)]
        \item $0 \cdot a = a \cdot 0 = 0$,
        \item $(-1) \cdot a = a \cdot (-1) = -a$,
        \item $(-a) \cdot b = a \cdot (-b) = -(a \cdot b)$,
        \item $(-1) \cdot (-1) = 1$,
        \item $(-a) \cdot (-b) = ab$.
    \end{enumerate}
\end{proposition}
\begin{proof}
    beebop
    \begin{enumerate}[(a)]
        \item $0a \eqby{+ id} (0 + 0)a \eqby{dist} 0a + 0a$ implies $0 = 0a$ by cancellation. \\
        $a0 \eqby{+ id} a(0 + 0) \eqby{dist} a0 + a0$ implies $0 = a0$ by cancellation.
        \item $a + (-1)a \eqby{\cdot id} 1a + (-1)a \eqby{dist} (1 - 1)a \eqby{+inv} 0a \eqby{a} 0$ implies $(-1)a = -a$ by additive inverse uniqueness. \\
        $a + a(-1) \eqby{\cdot id} a1 + a(-1) \eqby{dist} a(1 - 1) \eqby{+inv} a0 \eqby{a} 0$ implies $a(-1) = -a$ by additive inverse uniqueness.
        \item $-(ab) \eqby{b} (-1)ab \eqby{b} (-a)b \eqby{b} a(-1)b \eqby{b} a(-b)$.
        \item $(-1)(-1) \eqby{b} -(-1)$ but $-(-1) = 1$ by additive inverse uniqueness.
        \item $(-a)(-b) \eqby{b} a(-1)(-1)b \eqby{d} a1b \eqby{\cdot id} ab$.
    \end{enumerate}
\end{proof}

\sepline

A \keyword{}{module} (over a commutative ring) is given by the following data:
\begin{enumerate}[(1)]
    \item a commutative ring $R$,
    \item an abelian group $M$,
    \item a function $\mu : R \times M \to M$ such that
    \begin{enumerate}[(i)]
        \item $\mu(1, x) = x$ or equivalently $\mu(1, -) = \mu|_{1 \times M} = \id_M$
        \item $\mu(ab, x) = \mu(a, \mu(b, x))$ or equivalently the following diagram commutes
        \begin{cd}
            R \times R \times M \rar["\id_R \times \mu"] \dar["\mu_R \times \id_M"'] & R \times M \dar["\mu"] \\
            R \times M \rar["\mu"'] & M
        \end{cd}
    \end{enumerate}
\end{enumerate} 

\sepline

Let $R$ be a commutative ring.

An \keyword{$R$-module} is given by the following data:
\begin{enumerate}[(1)]
    \item an abelian group $M$ written additively, i.e., identity is $0$ and binary operation is $+$,
    \item a ring homomorphism $\mu : R \to \End(M)$, called \emph{scalar multiplication}.
    \item a $\Z$-module homomorphism $\mu : R \tensor_\Z M \to M$, called \emph{scalar multiplication}.
\end{enumerate}
We usually write $r \cdot m$ for the evaluation $\mu(r)(m)$.

\sepline

Let $R$ be a ring.

A \keyword{left $R$-module} is given by the following data:
\begin{itemize}
    \item an abelian group $M$, written additively, i.e., identity is $0$ and binary operation is $+$;
    \item a function $\mu : R \times M \to M$ called \emph{scalar multiplication} (write $r \cdot m = \mu(r, m)$);
\end{itemize}
such that
\begin{itemize}
    \item $1 \cdot m = m$ for all $m \in M$;
    \item $r \cdot (m + n) = (r \cdot m) + (r \cdot n)$ for all $r \in R$ and $m, n \in M$;
    \item $(r + s) \cdot m = (r \cdot m) + (s \cdot m)$ for all $r, s \in R$ and $m \in M$;
    \item $r \cdot (s \cdot m) = (rs) \cdot m$ for all $r, s \in R$ and $m \in M$.
\end{itemize}

A \keyword{right $R$-module} is given by the following data:
\begin{itemize}
    \item an abelian group $M$, written additively, i.e., identity is $0$ and binary operation is $+$;
    \item a function $\mu : M \times R \to M$ called \emph{scalar multiplication} (write $m \cdot r = \mu(m, r)$);
\end{itemize}
such that
\begin{itemize}
    \item $m \cdot 1 = m$ for all $m \in M$;
    \item $(m + n) \cdot r = (r \cdot m) + (r \cdot n)$ for all $r \in R$ and $m, n \in M$;
    \item $m \cdot (r + s) = (r \cdot m) + (s \cdot m)$ for all $r, s \in R$ and $m \in M$;
    \item $(m \cdot s) \cdot r = m \cdot (sr)$ for all $r, s \in R$ and $m \in M$.
\end{itemize}

\sepline

Let $R = (\RR, 0, 1, +, \cdot)$ be a ring.

We construct a the \keyword{opposite ring} $R^\op = (\RR, 0, 1, +, \cdot^\op)$, where
\[
    r \cdot^\op s = s \cdot r
\]

\sepline

Let $R$ be a ring and $M$ be an abelian group.

A left $R$-module structure on $M$ is equivalently a ring homomorphism $\lambda : R \to \End(M)$, with
\[
    r \cdot m = \lambda(r)(m)
\]

A right $R$-modules over $M$ is a ring homomorphism $R^\op \to \End(M)$.



\end{document}